package item19;

// 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

// 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
// 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
// 재정의 가능이란 public과 protected 메서드 중 final이 아닌 모든 메서드를 뜻한다.
// 문제 : 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어 날 수 있다.
// 해결 : @implSpec 어노테이션을 붙여 설명을 적어준다.
// 해결2 : 클래스의 내부 동작 과정 중간에 끼어들 수 있는 혹(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
// 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 "유일"

public class Super {
    
    // 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서 는 안된다. (예제 코드)
    // 이유 : 자식 클래스에서 재정의한 메서드가 생성자에서 자기 필드값을 초기화 하기 때문
    public Super() {
        overrideMe();
    }

    // NPE가 발생하지 않는 이유는 println이 null 입력도 받아들이기 때문
    public void overrideMe() {

    }

    // private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.
    private void overr() {

    }

}

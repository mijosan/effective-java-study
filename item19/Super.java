package item19;

// 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

// 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
// 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
// 재정의 가능이란 public과 protected 메서드 중 final이 아닌 모든 메서드를 뜻한다.
// 문제 : 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어 날 수 있다. (무차별 적으로 메서드를 재정의 한다면..)
// 해결 : @implSpec 어노테이션을 붙여 설명을 적어준다.
// 해결2 : 클래스의 내부 동작 과정 중간에 끼어들 수 있는 혹(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
// 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 "유일"
// Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.
// clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

// 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화 되지도 않았다.
// 이러한 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들수 있다.
// 이 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.

// 상속 금지법 : final 클래스, 모든 생성자를 private나 package-private으로 선언하고 public 정적 팩터리를 만들어 주는것
// 꼭 사용하겠다면 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남겨야한다.
public class Super implements Cloneable {
    
    // 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서 는 안된다. (예제 코드)
    // 이유 : 자식 클래스에서 재정의한 메서드가 생성자에서 자기 필드값을 초기화 하기 때문
    public Super() {
        overrideMe();
    }

    // NPE가 발생하지 않는 이유는 println이 null 입력도 받아들이기 때문
    public void overrideMe() {

    }

    // private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.
    private void overr() {

    }

    // clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
    // 특시 clone의 경우 잘못 될경우 원본 객체의 데이터를 참조하고 있다면 원본 객체도 피해를 입는것 이다.
    @Override
    protected Object clone() throws CloneNotSupportedException {
        overrideMe();
        return super.clone();
    }

}

// 핵심정리
// 클래스 내부에서 스스로 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은
// 그 클래스가 클래스가 쓰이는 한 반드시 지켜야 한다. 그렇지 않으면 그 내부 구현 방식을 믿고 활용
// 하던 하위 클래스를 오작동하게 만들 수 있다.
// 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.
// 일부 메서드를 protected로 제공하여 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 제공 할수 있다.
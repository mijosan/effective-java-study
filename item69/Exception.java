package item69;

// 예외는 진짜 예외 상황에만 사용하라 !

// 이유 : 반복문에 예외를 사용하면 장황하고 헷갈리며 속도도 느리고, 엉뚱한 곳에서 발생한 버그를 숨기기도 한다. !!!

// 예외는 오직 예외 상황에서만 사용하고 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.
// 잘 설계된 API라면 클라이언트가 정상적인 흐름에서 예외를 사용할 일이 없게 해야 한다.
// 특정 상태에서만 호출할수 있는 상태 의존적 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 한다. (ex) Iterator 인터페이스의 next와 hasNext)

public class Exception {
    
    public static void main(String[] args) {

        // 예외를 완전히 잘못 사용한 예
        
        // 전혀 직관적이지 않다는 사실 하나만으로도 코드를 이렇게 작성하면 안 되는 이유는 충분하다
        // 심지어 제대로 동작하지 않을 수도 있다. 반복문 안에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이버그를 숨겨 디버깅을 훨씬 어렵게 할것이다. !
        // 반복문의 몸체에서 호출한 메서드가 내부에서 관련 없는 배열을 사용하다가 AIOOBE을 일으켰다고 해보자.
        // 표준관용구였다면 이 버그는 예외를 잡지 않고 해당 스레드를 즉각 종료시킬 것이다. 반면 예외를 사용한 반복문은 버그 때문에 발생한 엉뚱한 예외를
        // 정상적인 반복문 종료 상황으로 오해하고 넘어간다.
        // 잘못된 추론을 근거로 성능을 높여보려 한 것이다.
        // 잘못된 추론 : JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료한다.
        // Iterator가 hasNext를 제공하지 않았다면 이렇게 작성 해야한다...
        try {
            int i = 0;
            while(true) {
                range[i++].climb();
            }
        } catch (ArrayIndexOutOfBoundsException e) {

        }

        // 다음과 같이 표준적인 관용구대로 작성했다면 모든 자바 프로그래머가 곧바로 이해했을 것이다.
        for (Mountain m : range) {
            m.climb();
        }
    }
}

// 핵심 정리
// 예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안되며,
// 이를 프로그래머에게 강요하는 API를 만들어서도 안 된다.

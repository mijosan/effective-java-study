package item49;

import java.math.BigInteger;
import java.util.Objects;

// 매개변수가 유효한지 검사하라 !

// 매개변수가 유효한지는 몸체가 시작되기 전에 검사해야한다. 이는 오류가 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.
// 매개변수 검사를 제대로 하지 않으면 발생하는 문제
// 1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
// 2. 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때다.
// 3. 더더 나쁜 상황은 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 때다.
// 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있다.

// public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.(@throws 자바독 태그를 사용)
// 보통 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException중 하나가 될 것이다.
// 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.

// 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
// 코드 20-1의 정적 팩터리 메서드를 생각해보라. 입력받은 int 배열의 List 뷰를 반환하는 메서드였다.
// 이 메서드는 Objects.requireNonNull을 이용해 null 검사를 수행하므로 클라이언트가 null 을 건네면 NullPointerException을 던진다.
// 만약 이 검사를 생략했다면 새로 생성한 List 인스턴스를 반환하는데, 클라이언트가 돌려받은 List를 사용하려 할 때 비로서 NPE가 발생한다.
// 이때가 되면 이 List를 어디서 가져왔는지 추적하기 어려워 디버깅이 상당히 괴로워질 수 있다.

// 생성자는 "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다.
// 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

// 매개변수 유효성을 검사해야 한다는 규칙에도 예외는 있다.
// 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산과정에서 암묵적으로 검사가 수행 될때이다.
// 하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠 수 있으니 주의 하자.
// 또한, 계산 과정에서 필요한 유효성 검사가 이뤄지지만 실패했을 때 잘못된 예외를 던지기도 한다. 이럴땐 예외 번역 관용구를 사용하여 API문서에 기재된 예외로 번역해줘야 한다.

// 핵심 !
// 매개변수에 제약을 두는게 좋다고 해석해서는 안 된다. 사실은 그 반대다.
// 메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건내 받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수로 좋다.
// 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않다.
public class Method {
    
    /**
     * 
     * @param m 계수 (양수여야 한다.)
     * @return 현재 값 mod m
     * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
     */
    public BigInteger mod(BigInteger m) {
        Objects.requireNonNull(m); // 자바 7에 추가된 메서드로 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.
                                   // 원하는 예외 메시지도 지정할 수 있다. 또한 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행 한다.
        if (m.signum() <= 0) {
            throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
        }

        return BigInteger.valueOf(3L);
    }

}
